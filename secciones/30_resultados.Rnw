\chapter{Resultados}

<<>>=
tipo_bat <- c(PLOMO = 1L, LITIO = 0L)
@

<<>>=
# preparación de tabla "atributos"
tanque_baterias <- atr_raw |>
 pivot_wider(names_from = "name", values_from = "value") |>
 clean_names() |>
 rename(mtto = periodicidad_mg,
        tanque = capacidad_tanque_motor) |>
 filter(motor_generador == "SI") |>
 select(-motor_generador, -tipo_motor) |>
 mutate(across(tipo_bateria, recode, !!!tipo_bat),
        across(mtto:tipo_bateria, as.factor),
        tanque = case_when(
         siteid == "GUA030" & is.na(tanque) ~ "155",
         siteid == "GUA073" & is.na(tanque) ~ "157",
         siteid == "GUA958" & tanque == "OTRO" ~ "157",
         TRUE ~ tanque),
         across(tanque, parse_integer))
@

<<>>=
# limpieza y feature engineering
mg_clean <- raw_mg |>
 mutate(
  status = if_else(status >= 1, "down", "up"),
  status = factor(status, levels = c("up","down")),
  across(c("duracion", "working"), ~ .x * 60),
  across(inicio:fin, ymd_hms),
  across(arranco, as.factor),
  dia = as.factor(day(inicio)),
  mes = as.factor(month(inicio)),
  .after = "fin")
@

<<>>=
# la fecha de inicio y de fin sirven para poder extraer el galonaje que tenía el MG al
# momento de la interrupción del servicio.
mg_set <- mg_clean |>
 select(siteid,
        fecha_inicio = inicio,
        fecha_fin    = fin)
@

<<eval=FALSE>>=
# debido a que el proceso de extraer los datos de la BD es muy tardado, este chunk no
# lo corremos, sino solo una vez para luego guardar los datos en un formato binario.
galonaje2 <- pmap_dfr(mg_set, ~ extraer_retina(conx = con,
                                              siteid = ..1,
                                              fecha_inicio = ..2,
                                              fecha_fin = ..3) |>
      collect()) |>
 mutate(across(contains("powercut"), ymd_hms))
@

<<>>=
galonaje <- read_fst("./galonaje.fst") |> as_tibble() |>
 rename(inicio = inicio_powercut, fin = fin_powercut)
@

<<>>=
# mg <-
mg <- mg_clean |>
 left_join(tanque_baterias, by = "siteid")
@


\section{Análisis Exploratorio}

\subsection{Estructura}

<<>>=
mg %>% glimpse()
@

\subsection{Variable dependiente}

\begin{figure}[H]
<<>>=
mg |>
 barra(status) +
 labs(title = "Clasificación desequilibrada")
@

\caption{El desafío de trabajar con conjuntos de datos desequilibrados es que la mayoría de
las técnicas de aprendizaje automático ignorarán y, a su vez, tendrán un rendimiento
deficiente en la clase minoritaria, aunque normalmente lo más importante es el rendimiento en
la clase minoritaria.}
   \label{fig:desbalance}
\end{figure}

En el gráfico \ref{fig:desbalance} se observa que la variable no está equilibrada. La clase
\va{up} tiene más casos que la clase \va{down}. \textbf{Si no balanceamos los datos entonces
lo que pasará es que nuestro modelo aprenderá de manera muy eficaz sobre cómo predecir el
caso negativo, es decir, cuando un sitio no se cae}

\subsection{Atípicos}

<<>>=
var_ok <- mg |>
 nearZeroVar(saveMetrics = T) |>
 rownames_to_column("var") %>%
 filter(!if_any(zeroVar:nzv, ~ .x == TRUE)) |>
 pull(var)
@

Debido a que las variables están en diferentes magnitudes y lo que nos interesa es evaluar la
presencia de atípicos, realizaremos una transformación a los valores utilizando la
\textbf{transformación del logaritmo ajustado}: $log(Y + 1)$. De esta forma los valores con 1
se convertirán en cero al aplicar el logaritmo.

<<>>=
sl <- mg %>%
 select(all_of(var_ok)) %>%
 select(status, duracion, working, tanque) |>
 mutate(across(where(is.numeric), ~ log(.x + 1)))
@

<<>>=
slice_sample(sl, n = 5) |> tabla(cap = "Visualización de atípicos")
@

Para graficar no será suficiente la transformación logarítmica, así que aplicaremos una
segunda transformación a nivel del eje $Y$. Esto nos permitirá ver de forma ordenada las
variables con información que tienen atípicos separada por cada uno de los distintos tipos de
status.

\begin{figure}[H]
<<fig.width=7>>=
sl %>%
 pivot_longer(cols = where(is.numeric),
              names_to = "variable",
              values_to = "valor") |>
 ggplot(aes(reorder_within(variable, valor, status, fun = median), valor)) +
 geom_boxplot(outlier.color = "red") +
 scale_x_reordered(name = "feature") +
 # scale_y_log10() +
 facet_grid(status ~ ., scales = "free") +
 drako +
 theme(axis.text.x  = element_text(angle = 90, vjust = 0.5, hjust = -0.01),
       axis.title.x = element_blank()) +
 labs(title        = "Atípicos con variables informativas",
      subtitle     = "Escala logarítmica")
@

\caption{Análisis de valores atípicos posterior a eliminar columnas con varianza cercana a cero}
   \label{fig:atip}
\end{figure}

Observamos en la figura \ref{fig:atip} que hay atípicos. Aunque el tratamiento de atípicos
puede mejorarse a través de una técnica llamada \emph{spatial sign} \citep[pag. ~71]{kuhn_applied_2013}
es posible que se deban investigar en profundidad la razón de estos outliers.

\subsection{Variables categóricas}

Ahora se verá la distribución de las variables categóricas, primero a nivel de
general y luego en función de la variable dependiente.

<<>>=
sbm <- mg |>
 select(where(is.factor))
@

<<>>=
plot_bar(sbm, ggtheme = drako) +
 scale_fill_OkabeIto()
@


\subsection{Análisis bivariado}

TODO: Aquí me quede. Tengo demasiados atípicos. Debo de hacer histogramas de las variables
cauntitativas.


<<>>=
columnas <- mg %>%
 select(where(is.factor), -dia) %>%
 names()
@

<<>>=
columnas %>%
 map(~  mg %>%
  select(-tanque) |>
  pivot_longer(cols = where(is.numeric)) %>%
  ggplot(aes(y = .data[[.x]], x = value)) +
  geom_boxplot(aes(fill = .data[[.x]]),
               outlier.colour = colorx[["rojo"]]) +
  # scale_x_log10() +
  # scale_fill_OkabeIto() +
  ggtitle(label = .x) +
  theme(legend.position = "bottom",
        legend.title = element_blank()) +
  facet_wrap(. ~ name, scales = "free", ncol = 2))
@


















